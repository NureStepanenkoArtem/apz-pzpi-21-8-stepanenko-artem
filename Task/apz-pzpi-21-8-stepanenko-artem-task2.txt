1 МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ


Користувачами розробленої системи є 3 типи акторів: клієнт, працівник та адміністратор.
Основними потребами клієнта є: можливість додавання своєї ділянки для охорони, перегляд даних про свою ділянку, перегляд залічених працівників до цієї ділянки, статус охорони на ділянці, можливість перегляду звітів із патрулем.
Основними потребами адміністратора є: перегляд даних про клієнта, перегляд даних про працівника, перегляд даних про ділянки у системі, перегляд даних про інвентар працівників та на складі, перегляд розрахованої загальної зарплатні працівникам.
Основними  потребами працівника є: перегляд інвентаря, який можливо буде закріпити, перегляд ділянки до якого закріплено працівника, перегляд даних про власника для контакту, перегляд звітів про патруль, формування звітів із повідомленням.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. додат. А.1).
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.


2 ПРОЄКТУВАННЯ БАЗИ ДАНИХ


	Для проєктування бази даних було розроблено ER-модель даних (див. додат. Б.1). Вона складається з 10 таблиць: користувачі, ролі, території, замовлення, охоронні розширення, взятий інвентар, інвентар, ранги охоронців, закріплені охоронці до замовлення, звіти від охоронців.
У базі даних наявні наступні зв’язки між сутностями:
− ролі і користувачі мають зв’язок один до багатьох бо до однієї ролі може належати багато користувачів;
− користувачі і території мають зв’язок нуль або один бо до одного користувача може належати одна ділянка, а може і ні;
− користувачі і охоронні розширення мають зв’язок нуль або один бо користувач може бути охоронцем, або не бути;
− взятий інвентар і охоронні розширення мають зв’язок один до багатьох бо один охоронець може узяти багато інвентарю одночасно, а може і не узяти;
− взятий інвентар і інвентар мають зв’язок один до багатьох бо інвентар можуть взяти багато, або можуть зовсім не брати;
− охоронні розширення і ранги мають зв’язок один до багатьох бо користувач може мати один ранг, але ранг може належати до багатьох користувачів;
− охоронні розширення і закріплені охоронці до замовлення мають зв’язок нуль або один до одного бо охоронець може бути закріплений лише за одною ділянкою, або зовсім не бути закріпленим;
− закріплені охоронці до замовлення і замовлення мають зв’язок один до багатьох бо до замовлення можуть бути залічені багато охоронців;
− замовлення і звіти охоронця мають зв’язок від нуля до багатьох бо до замовлення може належати багато звітів про патруль;
− звіти охоронця і охоронні розширення мають зв’язок від нуля до багатьох бо від охоронця може бути багато звітів, або не бути зовсім;


3 ТЕХНОЛОГІЇ ТА АРХІТЕКТУРНІ РІШЕННЯ


	Для написання серверної частини системи було обрано мову програмування C# з використанням технології ASP.NET Core, яка забезпечує швидку розробку, високу продуктивність та надійність.
У якості бази даних використано Microsoft SQL Server, до якої з серверного застосунка здійснюється доступ за допомогою технології Entity Framework Core, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 1).
	Для демонстрації та тестування API використовується OpenApi (Postman), що дозволяє зручно тестувати та документувати API, покращуючи якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі.
Для реалізації автентифікації та авторизації використано бібліотеку .NET Identity, що забезпечує гнучкий та потужний механізм для управління користувачами та їхнім доступом до різних частин системи. 
Для маршрутизації запитів використанні API контролери, що є вбудованими засобами розробки на ASP .NET Core. Вони дозволяють розділити програму на логічні компоненти, кожен з яких відповідає за обробку конкретного виду запитів або дій користувача. Це спрощує керування кодом та його розширення. 
Розроблений серверний застосунок побудований за принципами Clean Architecture запропонований Microsoft та складається з декількох шарів: User Interface рівень, Domain рівень Infrastructure рівень. У кожному шарі є свої залежності між шарами (див. рис. 2).
У якості способів організації програмного коду було обрано багато шаблонів проектування. Один із обраних був Repository шаблон який дозволяє розподілити зв’язок між базою даних і додатком. Ціль шаблону забезпечити простоту у випадку змінення бази даних або інших веб сервісів. Також усі об’єкти було розбито за допомогою шаблону Data Transfer Object (DTO). Ціль цього шаблону полягає у розподіленні об’єкта на компоненти за якими ми можемо мати одну модель об’єкта системи, та два об’єкта роботи із базою даних де останні роблять відгук до успішності операції. Також було обрано архітектурний шаблон Model-View-Controller (MVC). Задача цього шаблону полягає у розподіленні на шари між об’єктом, з яким йдуть операції, представленням, яке відображує дані, та контролером, який працює із іншими компонентами.
Для того щоб конкретно бачити відгуки програми під час роботи, було використано систему запису звітів зі станом Serilog. Задача цього рішення полягає у докладному розписі звітів про роботу програми під час роботи, наприклад, на сервері, де вже неможливо з тієї машини прямо дивитися дані. 
Архітектура серверного застосунка представлена на діаграмі пакетів (див. додат. В.1). Приклади частин коду серверного застосунка представлено у додатку Г.


4 СПЕЦИФІКАЦІЯ REST


REST API в розробленому проекті складається з 16 кінцевої точки. Кожна кінцева точка відповідає за надання даних клієнту та виконання бізнес логіки.
Специфікація кожної кінцевої точки REST API проекту наведена у таблиці 1.
Таблиця 1 – Специфікація REST.


ВИСНОВКИ


	У ході виконання лабораторної роботи були отримані навички з проектування серверної частини програмної системи, розробки сценаріїв використання, діаграм розгортання та пакетів, проектуванні бази даних. Була розроблена програмна реалізація серверної частини програмної системи. Були досліджені архітектурні шаблони, за якими можливо написання розподіленого коду.



